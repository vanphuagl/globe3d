<!DOCTYPE html>
<html lang="en">

<head>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .globe {
            width: 100vw;
            height: 80vh;
        }

        .globe_container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background-color: #f3f3f3;
            cursor: all-scroll;
        }

        .ocean {
            fill: #dfdfdf;
            stroke: #dfdfdf;
            stroke-width: 0;
            pointer-events: all;
            transition-duration: 0.4s;
            transition-property: fill, stroke;
        }

        .land {
            fill: #fff;
            pointer-events: all;
            transition: fill 0.4s;
        }

        .boundary {
            fill: none;
            stroke: none;
            stroke-linejoin: round;
            stroke-linecap: round;
            vector-effect: non-scaling-stroke;
        }

        .marker {
            stroke: #949494;
            stroke-width: 2;
            stroke-opacity: 1;
        }

        .ping {
            fill: none;
            stroke: #949494;
            stroke-width: 2;
        }

        .marker-label {
            font-size: 12px;
            fill: #333;
            font-family: Arial, sans-serif;
            text-anchor: middle;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <main>
        <div class="globe">
            <div class="globe_container">
                <div id="svgGlobe"></div>
            </div>
        </div>
    </main>

    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://d3js.org/topojson.v1.min.js"></script>
    <script>
        const locations = [
            { id: "a1b2c3d4-5e6f-7890-1234-56789abcdef0", name: "Tokyo, Japan", latitude: "35.6762", longitude: "139.6503", altitude: 40 },
            { id: "b2c3d4e5-6f78-9012-3456-789abcdef01", name: "New York, USA", latitude: "40.7128", longitude: "-74.0060", altitude: 10 },
            { id: "c3d4e5f6-7890-1234-5678-9abcdef012", name: "Cape Town, South Africa", latitude: "-33.9249", longitude: "18.4241", altitude: 25 },
            { id: "d4e5f6g7-8901-2345-6789-abcdef0123", name: "Sydney, Australia", latitude: "-33.8688", longitude: "151.2093", altitude: 20 },
            { id: "e5f6g7h8-9012-3456-789a-bcdef01234", name: "Reykjavik, Iceland", latitude: "64.1355", longitude: "-21.8954", altitude: 15 },
            { id: "f6g7h8i9-0123-4567-89ab-cdef012345", name: "Lima, Peru", latitude: "-12.0464", longitude: "-77.0428", altitude: 154 },
            { id: "g7h8i9j0-1234-5678-9abc-def0123456", name: "Kathmandu, Nepal", latitude: "27.7172", longitude: "85.3240", altitude: 1400 },
            { id: "h8i9j0k1-2345-6789-abcd-ef01234567", name: "Moscow, Russia", latitude: "55.7558", longitude: "37.6173", altitude: 156 },
            { id: "i9j0k1l2-3456-789a-bcde-f012345678", name: "Cairo, Egypt", latitude: "30.0444", longitude: "31.2357", altitude: 23 },
            { id: "j0k1l2m3-4567-89ab-cdef-0123456789", name: "Buenos Aires, Argentina", latitude: "-34.6037", longitude: "-58.3816", altitude: 25 },
            { id: "k1l2m3n4-5678-9abc-def0-123456789a", name: "Bangkok, Thailand", latitude: "13.7563", longitude: "100.5018", altitude: 2 }
        ];

        var w, h, scl, is3d = true;
        var svg = d3.select("#svgGlobe").append("svg");
        var projection = d3.geoOrthographic();
        var path = d3.geoPath().projection(projection);
        var map = svg.append("g");
        var markerGroup = svg.append("g").attr("class", "markers");

        let momentum = { velocityX: 0, velocityY: 0, decay: 0.95 };
        let lastMouseX = null;
        let lastMouseY = null;
        let isDragging = false;
        let animationFrameId = null;
        let lastTimestamp = null;

        const altitudes = locations.map((loc) => loc.altitude);
        const minAltitude = Math.min(...altitudes);
        const maxAltitude = Math.max(...altitudes);
        const midAltitude = minAltitude + (maxAltitude - minAltitude) / 2;
        const colorScale = d3.scaleLinear()
            .domain([minAltitude, midAltitude, maxAltitude])
            .range(["#949494", "#949494", "#949494"]);

        let selectedMarker = null;
        let initialDistance = null;
        let initialScale = null;

        const defs = svg.append("defs");
        const filter = defs.append("filter")
            .attr("id", "glow")
            .attr("x", "-50%")
            .attr("y", "-50%")
            .attr("width", "200%")
            .attr("height", "200%");
        filter.append("feGaussianBlur")
            .attr("stdDeviation", "3")
            .attr("result", "coloredBlur");
        const feMerge = filter.append("feMerge");
        feMerge.append("feMergeNode").attr("in", "coloredBlur");
        feMerge.append("feMergeNode").attr("in", "SourceGraphic");

        d3.json(
            "https://gist.githubusercontent.com/sarah37/dcca42b936545d9ee9f0bc8052e03dbd/raw/550cfee8177df10e515d82f7eb80bce4f72c52de/world-110m.json"
        ).then(function (json) {
            map.append("path")
                .datum({ type: "Sphere" })
                .attr("class", "ocean")
                .attr("d", path);

            map.append("path")
                .datum(topojson.merge(json, json.objects.countries.geometries))
                .attr("class", "land")
                .attr("d", path);

            map.append("path")
                .datum(topojson.mesh(json, json.objects.countries, function (a, b) {
                    return a !== b;
                }))
                .attr("class", "boundary")
                .attr("d", path);

            const markerGroups = markerGroup
                .selectAll("g")
                .data(locations)
                .join("g")
                .attr("class", "marker-group");

            markerGroups.append("circle")
                .attr("class", "ping")
                .attr("fill", "none")
                .attr("stroke", "#949494")
                .attr("stroke-width", 2)
                .attr("opacity", 0)
                .style("filter", "url(#glow)");

            markerGroups.append("circle")
                .attr("class", "marker")
                .attr("stroke", "#949494")
                .attr("stroke-width", 2)
                .attr("stroke-opacity", 1)
                .style("filter", "url(#glow)");

            markerGroups.append("text")
                .attr("class", "marker-label")
                .attr("dx", 0)
                .text((d) => d.name || "Unnamed")
                .style("fill", "#333")
                .style("font-family", "Arial, sans-serif")
                .style("text-anchor", "middle")
                .style("pointer-events", "none");

            resize();
            updateMarkers();
        }).catch(function (error) {
            console.error("Error loading JSON:", error);
        });

        function updateMarkers() {
            if (!markerGroup) return;

            const centerCoords = projection.invert([w / 2, h / 2]);
            markerGroup.selectAll(".marker-group")
                .attr("transform", (d) => {
                    const [x, y] = projection([d.longitude, d.latitude]);
                    return `translate(${x}, ${y})`;
                })
                .style("display", (d) => {
                    const coordinate = [d.longitude, d.latitude];
                    const gdistance = d3.geoDistance(coordinate, projection.invert([w / 2, h / 2]));
                    return gdistance > 1.57 ? "none" : null;
                });

            markerGroup.selectAll(".marker")
                .attr("fill", (d) => colorScale(d.altitude));

            markerGroup.selectAll(".marker-label")
                .style("visibility", (d) => {
                    const coordinate = [d.longitude, d.latitude];
                    const gdistance = d3.geoDistance(coordinate, projection.invert([w / 2, h / 2]));
                    return gdistance > 1.57 ? "hidden" : "visible";
                });

            const scaleFactor = projection.scale() / scl;
            const markerSize = Math.min(Math.max(5 / Math.sqrt(scaleFactor), 3), 8);
            const fontSize = Math.min(Math.max(12 / Math.sqrt(scaleFactor), 8), 14);
            const pingMaxSize = markerSize * 3.5;

            markerGroup.selectAll(".marker").attr("r", markerSize);
            markerGroup.selectAll(".marker-label")
                .style("font-size", `${fontSize}px`)
                .attr("dy", -markerSize * 2);

            markerGroup.selectAll(".ping").each(function (d) {
                const ping = d3.select(this);
                if (d === selectedMarker) {
                    ping.attr("opacity", 1)
                        .attr("r", markerSize)
                        .transition()
                        .duration(1500 / Math.sqrt(scaleFactor))
                        .ease(d3.easeCubicOut)
                        .attr("r", pingMaxSize)
                        .attr("opacity", 0)
                        .on("end", function () {
                            if (d === selectedMarker) {
                                d3.select(this)
                                    .attr("r", markerSize)
                                    .attr("opacity", 1)
                                    .call(
                                        () => ping.transition()
                                            .duration(1500 / Math.sqrt(scaleFactor))
                                            .ease(d3.easeCubicOut)
                                            .attr("r", pingMaxSize)
                                            .attr("opacity", 0)
                                            .on("end", function () {
                                                if (d === selectedMarker) {
                                                    d3.select(this).attr("r", markerSize);
                                                    updateMarkers();
                                                }
                                            })
                                    );
                            }
                        });
                } else {
                    ping.attr("opacity", 0).attr("r", markerSize);
                }
            });
        }

        function resize() {
            w = window.innerWidth;
            h = window.innerHeight;
            scl = Math.min(w, h) / 2.5;
            projection.translate([w / 2, h / 2]).scale(scl);
            svg.attr("width", w).attr("height", h);
            map.selectAll("path").attr("d", path);
            updateMarkers();
        }

        resize();
        d3.select(window).on("resize", resize);

        function switchProjection() {
            let s = projection.scale();
            let r = projection.rotate();
            let c = projection.center();
            if ((is3d = !is3d)) {
                projection = d3.geoOrthographic();
                projection.rotate([-c[0], -c[1]]);
            } else {
                projection = d3.geoMercator();
                projection.center([-r[0], -r[1]]);
            }
            projection.scale(s);
            map.selectAll("path").attr("d", path.projection(projection));
            resize();
        }

        // Drag functions
        function dragstarted() {
            isDragging = true;
            lastMouseX = d3.event.x;
            lastMouseY = d3.event.y;
            if (animationFrameId !== null) {
                cancelAnimationFrame(animationFrameId);
            }
            momentum.velocityX = 0;
            momentum.velocityY = 0;
            lastTimestamp = null;
        }

        function dragged() {
            if (!isDragging) return;

            const timestamp = Date.now();
            const dragDeltaX = d3.event.x - lastMouseX;
            const dragDeltaY = d3.event.y - lastMouseY;

            if (lastTimestamp) {
                const dt = timestamp - lastTimestamp;
                momentum.velocityX = dragDeltaX / dt;
                momentum.velocityY = dragDeltaY / dt;
            }

            const currentRotate = projection.rotate();
            const sensitivity = 0.1; // Giảm độ nhạy để mượt hơn
            currentRotate[0] = (currentRotate[0] + dragDeltaX * sensitivity) % 360; // Xoay ngang tự do
            currentRotate[1] = (currentRotate[1] - dragDeltaY * sensitivity) % 360; // Xoay dọc tự do
            projection.rotate(currentRotate);

            map.selectAll("path").attr("d", path);
            updateMarkers();

            lastMouseX = d3.event.x;
            lastMouseY = d3.event.y;
            lastTimestamp = timestamp;
        }

        function dragended() {
            isDragging = false;
            lastMouseX = null;
            lastMouseY = null;

            if (Math.abs(momentum.velocityX) > 0.01 || Math.abs(momentum.velocityY) > 0.01) {
                const animate = (timestamp) => {
                    if (isDragging) return;

                    const currentRotate = projection.rotate();
                    currentRotate[0] = (currentRotate[0] + momentum.velocityX * 10) % 360;
                    currentRotate[1] = (currentRotate[1] - momentum.velocityY * 10) % 360;
                    projection.rotate(currentRotate);

                    map.selectAll("path").attr("d", path);
                    updateMarkers();

                    momentum.velocityX *= momentum.decay;
                    momentum.velocityY *= momentum.decay;

                    if (Math.abs(momentum.velocityX) > 0.01 || Math.abs(momentum.velocityY) > 0.01) {
                        animationFrameId = requestAnimationFrame(animate);
                    } else {
                        animationFrameId = null;
                    }
                };
                animationFrameId = requestAnimationFrame(animate);
            }
        }

        var drag = d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended);
        svg.call(drag);

        // Zoom cho desktop
        function zoomedDesktop() {
            projection.scale(d3.event.transform.translate(projection).k * scl);
            map.selectAll("path").attr("d", path);
            updateMarkers();
        }

        var zoom = d3.zoom()
            .on("zoom", zoomedDesktop);
        svg.call(zoom);

        // Touch events
        function touchStarted(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                lastMouseX = event.touches[0].clientX;
                lastMouseY = event.touches[0].clientY;
                isDragging = true;
            } else if (event.touches.length === 2) {
                initialDistance = Math.hypot(
                    event.touches[0].clientX - event.touches[1].clientX,
                    event.touches[0].clientY - event.touches[1].clientY
                );
                initialScale = projection.scale();
            }
        }

        function touchMoved(event) {
            event.preventDefault();
            if (event.touches.length === 1 && isDragging) {
                const timestamp = Date.now();
                const dragDeltaX = event.touches[0].clientX - lastMouseX;
                const dragDeltaY = event.touches[0].clientY - lastMouseY;

                if (lastTimestamp) {
                    const dt = timestamp - lastTimestamp;
                    momentum.velocityX = dragDeltaX / dt;
                    momentum.velocityY = dragDeltaY / dt;
                }

                const currentRotate = projection.rotate();
                const sensitivity = 0.25;
                currentRotate[0] = (currentRotate[0] + dragDeltaX * sensitivity) % 360;
                currentRotate[1] = (currentRotate[1] - dragDeltaY * sensitivity) % 360;
                projection.rotate(currentRotate);

                map.selectAll("path").attr("d", path);
                updateMarkers();

                lastMouseX = event.touches[0].clientX;
                lastMouseY = event.touches[0].clientY;
                lastTimestamp = timestamp;
            } else if (event.touches.length === 2) {
                const currentDistance = Math.hypot(
                    event.touches[0].clientX - event.touches[1].clientX,
                    event.touches[0].clientY - event.touches[1].clientY
                );
                const scaleFactor = currentDistance / initialDistance;
                const newScale = Math.max(scl * 0.5, Math.min(scl * 2, initialScale * scaleFactor));
                projection.scale(newScale);
                map.selectAll("path").attr("d", path);
                updateMarkers();
            }
        }

        function touchEnded(event) {
            event.preventDefault();
            if (event.touches.length === 0) {
                dragended();
            }
            initialDistance = null;
            initialScale = null;
        }

        svg.node().addEventListener("touchstart", touchStarted, { passive: false });
        svg.node().addEventListener("touchmove", touchMoved, { passive: false });
        svg.node().addEventListener("touchend", touchEnded, { passive: false });
    </script>
</body>

</html>